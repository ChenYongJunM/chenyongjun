<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Swift笔记 | Mr Chen 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="YongJun Chen">
    
    

    <meta name="description" content="一. 控制流
for in 可以遍历数组、字典、range范围。
switch 可以处理字符串、字符、元祖、区间等

二.  函数
函数返回值可以是函数 func demo(a:Bool) -&amp;gt; (Int)-&amp;gt;Int
嵌套函数 func A(){ func B(){} }

三、闭包
提供参数名缩写$0、$1…可以顺序访问闭包参数、上下文推断参数类型、单行表达式可以隐藏return
闭">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift笔记 | Mr Chen">
<meta property="og:url" content="https://chenyongjunm.github.io/chenyongjun/2016/08/10/Swift笔记/index.html">
<meta property="og:site_name" content="Mr Chen">
<meta property="og:description" content="一. 控制流
for in 可以遍历数组、字典、range范围。
switch 可以处理字符串、字符、元祖、区间等

二.  函数
函数返回值可以是函数 func demo(a:Bool) -&amp;gt; (Int)-&amp;gt;Int
嵌套函数 func A(){ func B(){} }

三、闭包
提供参数名缩写$0、$1…可以顺序访问闭包参数、上下文推断参数类型、单行表达式可以隐藏return
闭">
<meta property="og:updated_time" content="2016-08-11T08:32:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift笔记 | Mr Chen">
<meta name="twitter:description" content="一. 控制流
for in 可以遍历数组、字典、range范围。
switch 可以处理字符串、字符、元祖、区间等

二.  函数
函数返回值可以是函数 func demo(a:Bool) -&amp;gt; (Int)-&amp;gt;Int
嵌套函数 func A(){ func B(){} }

三、闭包
提供参数名缩写$0、$1…可以顺序访问闭包参数、上下文推断参数类型、单行表达式可以隐藏return
闭">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/chenyongjun/css/uno.css">
    <link rel="stylesheet" href="/chenyongjun/css/highlight.css">
    <link rel="stylesheet" href="/chenyongjun/css/archive.css">
    <link rel="stylesheet" href="/chenyongjun/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Mr Chen</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          正在修行的路上
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/chenyongjun/#blog" title="" class="">首页</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Swift笔记</h1>

    

    <div class="post-meta">
      <time datetime="2016-08-10" class="post-meta__date date">2016-08-10</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="一-控制流"><a href="#一-控制流" class="headerlink" title="一. 控制流"></a>一. 控制流</h3><ul>
<li>for in 可以遍历数组、字典、range范围。</li>
<li>switch 可以处理字符串、字符、元祖、区间等</li>
</ul>
<h3 id="二-函数"><a href="#二-函数" class="headerlink" title="二.  函数"></a>二.  函数</h3><ul>
<li>函数返回值可以是函数 func demo(a:Bool) -&gt; (Int)-&gt;Int</li>
<li>嵌套函数 func A(){ func B(){} }</li>
</ul>
<h3 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h3><ul>
<li>提供参数名缩写$0、$1…可以顺序访问闭包参数、上下文推断参数类型、单行表达式可以隐藏return</li>
<li>闭包的函数体部分有in关键字引入</li>
</ul>
<ul>
<li><p>闭包表达式语法可以使用常量、变量和 inout 类型作为参数,不提供默认值。 也可以在参数列表的最后使用可变参数。 元组也可以作为参数和返回值。</p>
</li>
<li><p>​</p>
<blockquote>
<p>let someProperty: SomeType ={</p>
<p>​    //在这个闭包中给someProperty创建一个默认值 someValue必须和SomeType类型相同</p>
<p>​    return someValue</p>
<p>}</p>
<p>闭包结尾的大括号后面接了一对空的小括号，告诉swift需要立刻执行此闭包，如果忽略了这对括号相当于把闭包赋值给了属性。</p>
<p>如果使用闭包初始化属性值，闭包执行时，实例的其他部分都还没有初始化，这意味着你不能够在闭包里王文其他的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐士是self属性，或者调用其他的实例方法。</p>
</blockquote>
</li>
</ul>
<h3 id="四、枚举"><a href="#四、枚举" class="headerlink" title="四、枚举"></a>四、枚举</h3><ul>
<li>枚举类型是一等(first-class)类型，支持：属性、实例方法、函数、扩展、协议几乎和类相似。 </li>
<li>相关值enum Barcode {case UPCA(Int, Int, Int) case QRCode(String)}。</li>
</ul>
<h3 id="五、类和结构体"><a href="#五、类和结构体" class="headerlink" title="五、类和结构体"></a>五、类和结构体</h3><ul>
<li>共同点:<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值 </li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能 </li>
<li>符合协议以对某类提供标准功能</li>
</ul>
</li>
<li>类还有如下附加功能<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所被分配的资源<ul>
<li>引用计数允许对一个类的多次引用</li>
</ul>
</li>
</ul>
</li>
<li>结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例。 相反类实例没有</li>
<li>结构体和枚举是值类型(赋值等操作是拷贝一份副本)、类是引用类型</li>
<li>===(“等价于”)表示两个类类型(class type)的常量或者变量引用同一个类实例</li>
<li>类和结构体的选择：<ul>
<li>按照通用的准则，当符合一条或多交一下条件时，轻考虑构建结构体：<ul>
<li>结构体的主要目的是用来封装少量相关简单数据值。</li>
<li>一个结构体实例赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。</li>
<li>结构体不需要去集成另一个已存在类型的属性或者行为。 <ul>
<li>（例：集合形状的大小(width,height)）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>String、Array、Dictionary均以结构体实现</li>
<li>如果为值类型定义了一个自定义构造器，将无法访问莫问的逐一对象构造器（可以以extension的方式添加构造方法）</li>
<li>构造器链规则：<ul>
<li>指定构造器必须调用其直接父类的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其他构造器</li>
<li>便利构造器必须最终以调用一个指定构造器结束</li>
<li>总：指定构造器必须总是向上代理， 便利构造器必须总是横向代理</li>
</ul>
</li>
<li>可失败构造器定义:在init关键字后面添加问号</li>
<li>必要构造器：在类的构造器添加required修饰符表示子类必须实现该构造器。子类覆盖基类的必要构造器时，必须同样添加required修饰符。如果父类必要构造器能满足需求，则无需在子类实现。</li>
</ul>
<h3 id="六、属性"><a href="#六、属性" class="headerlink" title="六、属性"></a>六、属性</h3><ul>
<li><p>如果创建了一个结构体的实例并赋值给一个常量,则无法修改实例的任何属性,即使定义了变量存储属性。这种行为是由于结构体(struct)属于值类型。当值类型的实例被声明为常量的时候,它的所有属性也就成了常量。</p>
</li>
<li><p>属于引用类型的类(class)则不一样,把一个引用类型的实例赋给一个常量后,仍然可以修改实例的变量属性。</p>
</li>
<li><p>延迟储存属性:是指当第一次被调用的时候才会计算其初始值的属性。（延迟储存属性必须申明成变量var,因为属性值在实例构造完之前可能无法得到）</p>
</li>
</ul>
<p>  （例: lazy var demo = demo()）            </p>
<ul>
<li>使用关键字final 来防止被重写</li>
</ul>
<p>  ​                </p>
<h3 id="七、析构过程-Deinitialization"><a href="#七、析构过程-Deinitialization" class="headerlink" title="七、析构过程(Deinitialization)"></a>七、析构过程(Deinitialization)</h3><ul>
<li>相当于OC dealloc</li>
</ul>
<h3 id="八、ARC"><a href="#八、ARC" class="headerlink" title="八、ARC"></a>八、ARC</h3><ul>
<li>解决实例之间的循环强引用：<ul>
<li>弱引用(weak reference) 可以被设置成nil，销毁后对象会被设置成nil。</li>
<li>无主引用(unowned reference): 无主引用是非可选类型，无主引用总是可以被直接访问，ARC无法再实例销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil.</li>
<li>[weak self]、[unowned self]</li>
</ul>
</li>
</ul>
<h3 id="九、类型转换"><a href="#九、类型转换" class="headerlink" title="九、类型转换"></a>九、类型转换</h3><ul>
<li>is ：检查一个实例是否属于特定子类型，返回true or false</li>
<li>as：一个常量或变量可能在幕后属于一个子类。可以尝试使用as关键字向下转到它的子类型， 当不确定肯定能转换成功需要使用可选形式。</li>
<li>Any 和 AnyObject的类型转换<ul>
<li>Any：可以表示任何类型，除了方法类型(function types)</li>
<li>AnyObject 可以代表任何class类型的实例</li>
</ul>
</li>
</ul>
<h3 id="十、扩展-Extensions"><a href="#十、扩展-Extensions" class="headerlink" title="十、扩展(Extensions)"></a>十、扩展(Extensions)</h3><ul>
<li>扩展和Objective-C中的分类(categories)类似,swift没有扩展名字</li>
<li>Swift中的扩展：<ul>
<li>添加计算行属性和计算静态属性   -(不能添加储存属性)</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
</li>
<li>扩展可以添加新的计算属性，但是不可以添加储存属性，也不可以向已有属性添加属性观察器(property observers)</li>
<li>如果你使用扩展提供了一个新的构造器，你依旧有责任保证构造过程能够让所有实例完全初始化</li>
</ul>
<h3 id="十一、计算属性和储存属性"><a href="#十一、计算属性和储存属性" class="headerlink" title="十一、计算属性和储存属性"></a>十一、计算属性和储存属性</h3><ul>
<li>储存属性:</li>
<li>储存属性就是储存在特定类、结构体里的一个常量或者变量<ul>
<li>可以在定义的时候指定默认值</li>
<li>可以在构造过程中设置或者修改值</li>
</ul>
</li>
<li>计算属性：<ul>
<li>枚举、类、结构体除了拥有储存属性，还可以定义计算属性<ul>
<li>不直接储存值，而是提供一个getter和一个可选的setter来间接获取、设置值    ​</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十二、协议"><a href="#十二、协议" class="headerlink" title="十二、协议"></a>十二、协议</h3><ul>
<li>对属性的规定：经常以var前缀声明其变量属性，在声明后加上{set get}来表示属性是可读写的。</li>
<li>对方法的规定：方法支持可变参数(cariadic parameter)，不支持参数默认值(default value)</li>
<li>对可变方法的规定：mutating表示可以在该方法中修改实例及属性的所属类型。 结构体、枚举实现协议中的mutating方法时，必须写mutating关键子，类实现协议中的mutating方法时不用。</li>
<li>对构造器的规定：可以要求遵守类型实现特性构造器</li>
<li>协议类型：<ul>
<li>作为函数、方法或者构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或者属性的类型</li>
<li>作为数组、字典或者其他容器中的元素类型</li>
</ul>
</li>
<li>类专属协议：添加class关键字限制协议只能适配到类(class)类型，该关键字必须是第一个出现在协议的继承列表中</li>
<li>@objec 用来表示协议是可选的，也可以用来表示暴露给Objective-C的代码，只对类有效。</li>
</ul>
<h3 id="十三、访问控制"><a href="#十三、访问控制" class="headerlink" title="十三、访问控制"></a>十三、访问控制</h3><ul>
<li>Public：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个借口或Framework是可以被任何人使用时，你可以将其设置为Public级别</li>
<li>Internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个借口或Framework作为内部结构使用时，你可以将其设置为internal级别</li>
<li>Private：只能在当前源文件中使用的实体，称为私有实体。使用Private级别，可以用做隐藏某些功能的实现细节。</li>
<li>嵌套类型：如果在private级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有private访问级别。如果在public或者internal级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal访问级别。如果想让嵌套类型拥有public访问级别，那么需要对该嵌套类型进行明确的访问级别申明</li>
<li>子类：子类的访问级别不得高于父类的访问级别。</li>
</ul>
<h3 id="十四、运算符"><a href="#十四、运算符" class="headerlink" title="十四、运算符"></a>十四、运算符</h3><ul>
<li>??操作符，先对可选值进行拆包，如果不为nil返回操作符前面的值，如果为空返回后者</li>
<li>重载一元操作符，需要添加关键字prefix or postfix。 赋值运算=和三元运算符a?b:c 不能被重载。</li>
<li>自定义运算符：自定义运算符可以在全局使用，需要使用operator关键字。使用prefix、infix or postfix标记运算符使用的位置。</li>
</ul>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/chenyongjun/js/jquery.min.js"></script>
    <script src="/chenyongjun/js/main.js"></script>
    <script src="/chenyongjun/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/chenyongjun/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
